1. Создал Обьект User вида
public class User {
    private int id;
    private Integer serial;
    private String name;
    private String[] kidsName;
    private Integer[] kardNum;
    public User(int id, Integer serial, String name, String[] kidsName, Integer[] kardNum) {
        this.id = id;
        this.serial = serial;
        this.name = name;
        this.kidsName = kidsName;
        this.kardNum = kardNum;
    }

2. Создать несколько объектов User.
Для подсчет размера обьекта необходима считать все не статиеские поля.
Если поле ссылочный тип то так же учитываем размер ссылки, если это массив ссылочных типов то дополнительно учитываем количесвто ссылок.
По созданому мной классу обьект содержит как примитивные типы так и сылочные типа а так же массивы ссылочных типов.
Для начала создадим пустой обьект User конструктором по умолчанию и посчитаем его размер.
предворительно уточню что моя система является x64 и разме кучи макс 16 гб.
Итак new User();
		1. размер заголовка обьекта будет иметь 12 байт.
		2. поле int id = 32 битам = 4 байта.
		3. поле Integer serial = пустое null, содержит только указатель 4 байта.
		4. поле String name = пустое null, содержит только указатель 4 байта.
		5. Поле String[] kidsName = пустое null, содержит только указатель 4 байта.
		6. Поел Integer[] kardNum = пустое null, содержит только указатель 4 байта.
итого: 12 + 4 + 4 + 4 + 4 + 4 = 32 байта. выравнивание по 8 не требуется.
Дале создадим два обьекта User проведем их последовательный расчет.
	new User(1, 2, "name", new String[]{"k1", "k2"}, new Integer[]{5, 6});
		1. заголовок; 	12 байт.
		2. int id = 1;	4 байта.
		3. Integer serial = 2;	12 байт заголовок + 4 байта значение = 16 байт.
		4. Поле String = "name"; переходем в стринг и считаем все поля не static,
				это 4 поля byte coder 1 байт, int Hash 4 байт, boolean hashIsZero 1 байт 1+4+1= 6 байт.
				и масив символов new byte[]{'n','a','m','e'}, получаем 4 элемента byte, 4*1 = 4 байта.
				                                4 байта на длину масива
												12 байт на ссылку массива
												ссылка на String 12 байт,
												получаем 6 + 4 + 4 + 12 + 12 = 38 + выравниване по 8:2 = 40;
		5. Поле String[]{"k1","k2"} получаем два Stringa по 40 байта, 
											размер массива int 4 байта,
											ссылка на масив 12 байт,
											получаем 40*2+12+4=96 байта.
		6. Поле Integer[]{5, 6} получаем два Integer по 16 байт
											размер массива 4 байта,
											ссылка на массив 12 байт,
											получаем 16*2+4+12 = 48 байт.
	Общий этог нашего User = 12+4+16+40+96+48=216 байт.										
3. Нужно найти информацию. Сколько памяти занимает пустой объект без полей.
Пустой обьект JVM пердстовляет из себя заголовок (Class header), который сосотоит из указателя (Class pointer) и маркера (mark word-маркер GC). так же дополнителнением к размеру является вырвнивание по байтам что озночает кратность результата 8 байтам.
Размер заголовка зависит от разрядности опеарционной системы и  параметра сжатия
+XX:+UseCompressedOops (значение по умолчанию включено).
Для системы x32_64 при раземере кучи памяти до 32 ГБ
Пустой обьек будет иметь размер: 8 байт mark word + 4 байта заголовок + выравнивание по 8 байтам итого = 16 байт.
заголовок 12 байт + выравнивание 4 байта.
При параметре +XX:-UseCompressedOops значение для 32x разардной системы не изменится. я для x64 указатель увеличется до 8 байт, 
получим Маркеровка 8 байт, заголовок 8 байт итог 16 байт так как смешение не требуется, то размер совпадет с предыдущим значением, для заполненых обьектов размер увеличится.
заголовок 16 байт и плюс выравнивание 0 байт.

4. Добиться состояния, когда виртуальная машины вызывает сборщик мусора самостоятельно. За счет ключей xmx.
после добовления более 1200 обектов без ссылок на обьект GC все же запустился.Параметр -Xmx4m (размер кучи 4 мегабайта) для G1GC минимальный размер. Это связано с тем что edem эдем заполнился а при вызове minоrGC помеченных обьектов не оказалось, часть обьектов очистилось из памяти. Вынесли мусор. 